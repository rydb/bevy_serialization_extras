//! A simple 3D scene with light shining over a cube sitting on a plane.

use std::{path::PathBuf, thread::spawn};

use bevy::{prelude::*, window::PrimaryWindow, render::mesh::shape::Cube, ecs::{system::EntityCommands, bundle, storage::Table, component::TableStorage}, transform::commands};
use bevy_serialization_extras::{plugins::SerializationPlugin, resources::{SaveRequest, LoadRequest, AssetSpawnRequest, AssetSpawnRequestQueue}, bundles::physics::{PhysicsBundle, PhysicsFlagBundle}, loaders::urdf_loader::Urdf, wrappers::link::{Linkage, LinkQuery, JointFlag, JointAxesMaskWrapper, LinkQueryItem}, queries::FileCheckPicker};
use bevy_ui_extras::systems::visualize_right_sidepanel_for;
use egui::{TextEdit, text::LayoutJob, TextFormat, ScrollArea};
use moonshine_save::save::Save;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use bevy_serialization_extras::bundles::model::ModelBundle;
use bevy_egui::EguiContext;
use bevy_rapier3d::{plugin::{RapierPhysicsPlugin, NoUserData}, render::RapierDebugRenderPlugin, dynamics::{ImpulseJoint, RigidBody, PrismaticJointBuilder, RapierImpulseJointHandle}};
use bitvec::{prelude::*, view::BitView};


use bevy_serialization_extras::ui::*;


fn main() {

    App::new()

    .add_plugins(DefaultPlugins.set(WindowPlugin {exit_condition: bevy::window::ExitCondition::OnPrimaryClosed, ..Default::default()}))
        .add_plugins(SerializationPlugin)
        .add_plugins(RapierPhysicsPlugin::<NoUserData>::default())
        .add_plugins(RapierDebugRenderPlugin::default())
        //.add_plugins(SelecterPlugin)
        .add_plugins(WorldInspectorPlugin::new())
        //.add_systems(Update, load_urdfs_handles_into_registry)
        .add_systems(Startup, setup)
        //.add_systems(Update, (visualize_right_sidepanel_for::<Save>, save_file_selection))
        //.add_systems(Update, manage_serialization_ui)
        .add_systems(Update, debug_widgets_window)
        //.add_systems(Update, edit_jointflag_widget)
        //.add_systems(Update, print_links)
        .run();
}

pub trait Spawnable {
    fn spawn_components_list(item: LinkQueryItem<'_>, e: Entity, commands: Commands);
}

pub fn add_component_to_entity<T: Component>(e: Entity, mut commands: Commands, component: T) {
    //commands.spawn(component)
    commands.entity(e)
    .insert(component);
}
/// testing only, this should be generated by a proc macro
impl Spawnable for LinkQuery {
    fn spawn_components_list(item: LinkQueryItem<'_>, e: Entity, mut commands: Commands){    
        match item.name {
            Some(name) => {
                commands.entity(e)
                .insert(name.clone())
                ;
            },
            None => {}
        };
        commands.entity(e)
        .insert(item.structure.clone())
        ;

        match item.inertial {
            Some(inertial) => {
                commands.entity(e)
                .insert(inertial.clone())
                ;
            }
            None => {}
        }

        match FileCheckPicker::from(item.visual) {
            FileCheckPicker::PathComponent(component) => {
                commands.entity(e)
                .insert(component)
                ;
            }
            FileCheckPicker::PureComponent(component) => {
                commands.entity(e)
                .insert(component)
                ;
            }
        }
        match item.collision {
            Some(collision) => {
                commands.entity(e)
                .insert(collision.clone())
                ;
            }
            None => {}
        }

        // match item.joint {
        //     Some(joint) => {
        //         commands.entity(e)
        //         .insert(bundle)
        //     }
        // }
    }
}



/// set up a simple 3D scene
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    //mut urdfs: ResMut<Urdfs>
) {

}
